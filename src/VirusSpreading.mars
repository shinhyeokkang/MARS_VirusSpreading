model VirusSpreading

use Mars

grid-layer City as city

//Sheep walk around by chance, if you have grass under you, it is eaten
//If there is no grass beneath you, nothing will be done
//Every few rounds a new sheep is spawned
//It receives half of the Energy 
agent Human on City{
	observe var Rule = ""
	observe var Energy : integer //when energy goes to 0, human die.
	observe var Infected : bool = false
	observe var Immune : bool = false
	observe var obedient : bool = false
	//Regulator: "Sheep_gain_from_food" = Energy grows when eating
	// 			 "Sheep_reproduce" = Percentage chance of offspring 
	external observe var Human_gain_by_age : integer
	external observe var Vulnerable_class_ratio : integer
	external observe var Obey_ratio : integer
	external observe var Government_announce_date : integer 
	
	passive IsInfected() => return Infected
	passive IsImmune() => return Immune
	passive SetInfected(Bool : bool) => Infected = Bool
	//var Target : Grass
	
	initialize{
		//Spawn somewhere in the grid when the simulation starts
		pos at #(random(city.DimensionX), random(city.DimensionY))
		var nearHuman = explore Human in 2;
		var Obey = Random(100);

		var Class = Random(100);
		if(Class < Vulnerable_class_ratio) {
			Energy = random(Human_gain_by_age);
		}
		else {
			Energy = random(Human_gain_by_age) + 15;
		}
	}
	
	tick {
		Move();
		
		if (Infected === true) {
			var Neighbors = explore Human in 2		// in radius
		
			if (Neighbors[0] !== nil) {
				each (var Neighbor in Neighbors) {		// for each Neighbor 
					if (Neighbor.IsInfected() === false and Neighbor.IsImmune() === false) {		// if Neighbor not already infected or immune
						Infect(Neighbor, distance(Neighbor))		// try to infect Neighbor
					}
					
				}
			}
		}
		
		loss();
		
		if ( Ticks/24 >= Government_announce_date ) {
			if(Obey < Obey_ratio) {
				obedient = true;
			}
		}
	}
	
	def Move(){
	
		if(obedient == true&&TargetDistance <= 2&&nearHuman[0] != nil){
			Rule = "R3 - Social Distancing"
			
			nearx = nearHuman[0].GetPositionX()//runaway from the human
			neary = nearHuman[0].GetPositionY()
			if(TargetDistance2>2){
				move me 1 to #(2*xcor-nearx,2*ycor-neary)	
				}
		 	else if (TargetDistance3>2){
				  nearx2 = nearHuman[1].GetPositionX()//runaway from the human
				  neary2 = nearHuman[1].GetPositionY()
				  var avoidx = (nearx+nearx2)/2 // get middle point of two near human
				  var avoidy = (neary+neary2)/2
				  
				  move me 1 to #(2*xcor-avoidx,2*ycor-avoidy)
				  }
				  
			else {
				move me 2 to #(random(city.DimensionX), random(city.DimensionY))
			}
		}
		else{
			move me random(100) to #(random(city.DimensionX), random(city.DimensionY))
		}
	}
	
	def Infect(Neighbor : Human, Distance : real) : bool {
		var RandomValue = random(100);	// get a random value 0-99
		
		// different infection rates based on Distance
		if (Distance <= 0.5) {
			return CalcInfected(Neighbor, RandomValue, 80); // for example, 80% to get infected if Distance <= 0.5
		} 

		if (Distance <= 1) {
			return CalcInfected(Neighbor, RandomValue, 60);
		} 
		
		if (Distance <= 1.5) {
			return CalcInfected(Neighbor, RandomValue, 40);
		} 

		if (Distance <= 2) {
			return CalcInfected(Neighbor, RandomValue, 20);
		} 
	}
	
	def CalcInfected(Neighbor : Human, RandomValue : real, ComparedTo : real) : bool {
			if (RandomValue < ComparedTo) {
				Neighbor.SetInfected(true);
				return true;
			} else {
				return false;
			}		
	}
	
	 
	passive Killed() => kill me
	
	//Die "Mutter" gibt dem "Kind" Werte von sich mit

	passive GetPositionX() => return xcor
	passive GetPositionY() => return ycor
	
	def recover(){ //antibodies
		if (Infected){
			Infected = false //set not infected
			Immune = true    //set immune
		}		
		
	}
	
	def loss(){		//TODO: add prob for recover() => affects the results
		if(Infected){ //TODO: how about human get infected on the 3rd day?
			Ticks++
		}
		
		if(not Immune){
			if(random(100)<15){ //15% death rate
				kill me
			}
			if(Energy <= 0 ){
				kill me   //die when energy <= 0
			}else{
				Energy--//loss energy
			}
			if(Ticks/24 >= 15 and Energy >0){ //1 Tick == 1 hour
				recover()
			}
		}		
		//if immune then do nothing
	}

}

