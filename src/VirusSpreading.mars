model VirusSpreading

use Mars

grid-layer City as city


agent Human on City{
	observe var Rule = ""
	observe var Energy : integer //when energy goes to 0, human die.
	observe var Infected : bool = false
	observe var Immune : bool = false
	observe var obedient : bool = false
	observe var Ticks: integer //count for recover
	
	var nearHuman : [Human]
	var TargetDistance : real = 10
	var TargetDistance2 : real = 10
	var TargetDistance3 : real = 10
	
	external observe var Human_gain_by_age : integer
	external observe var Vulnerable_class_ratio : integer
	external observe var Obey_ratio : integer
	external observe var Government_announce_date : integer 
	external observe var Initial_infected_rate : integer
	
	var Obey = random(100); 
	
	 
	passive IsInfected() => return Infected 
	passive IsImmune() => return Immune
	passive SetInfected(Bool : bool) => Infected = Bool
	
	initialize{
		//Spawn somewhere in the grid when the simulation starts
		pos at #(random(city.DimensionX), random(city.DimensionY))
		
		var Class = random(100);
		if(Class < Vulnerable_class_ratio) {
			Energy = random(Human_gain_by_age);
		}
		else {
			Energy = random(Human_gain_by_age) + 15;
		}
		
		var infect = random(100);
		if(infect <= Initial_infected_rate) {
			Infected = true
		}
	
	}
	
	tick {
		
		Move();
		
		if (Infected === true) {
			var Neighbors = explore Human 	
			var NearestDistance = distance(Neighbors[0])
		
			if (NearestDistance < 2) {
				Neighbors = explore Human in 2
				each (var Neighbor in Neighbors) {		// for each Neighbor 
					var NeighborDistance = distance(Neighbor)
					if (NeighborDistance < 2 and Neighbor.IsInfected() === false and Neighbor.IsImmune() === false) {		// if Neighbor not already infected or immune
						 
						 Infect(Neighbor, distance(Neighbor))		// try to infect Neighbor
					}
					
				}
			}
		}
		
		loss();
		
		if ( Ticks/24 >= Government_announce_date ) {
			if(Obey < Obey_ratio) {
				obedient = true;
			}
		}
	}
	
	def Move(){
	    nearHuman = explore Human
	    if(nearHuman[0] !== nil){
			TargetDistance = distance nearHuman[0]
			
		}
		if(nearHuman[1] !== nil){
			TargetDistance2 = distance nearHuman[1]
			
		}
		if(nearHuman[2] !== nil){
			TargetDistance3 = distance nearHuman[2]
			
		}
		
		if(obedient === true and TargetDistance <= 2 ){
			Rule = "R3 - Social Distancing"
			//nearHuman = explore Human in 2;
			var nearx = nearHuman[0].GetPositionX()//runaway from the human
			var neary = nearHuman[0].GetPositionY()
			if (TargetDistance2>2){
				move me 1 to #(2*xcor-nearx,2*ycor-neary)	
				}
				else if (TargetDistance3>2){
				  var nearx2 = nearHuman[1].GetPositionX()//runaway from the human
				  var neary2 = nearHuman[1].GetPositionY()
				  
				  var avoidx = Plus(nearx,nearx2) // get middle point of two near human
				  var avoidy = Plus(neary,neary2)
				  
				  var ax = Divide(avoidx);
				  var ay = Divide(avoidy);
				  
				  move me 1 to #(2*xcor-ax,2*ycor-ay)
				  }
				  
			else{
				move me 2 to #(random(city.DimensionX), random(city.DimensionY))
			}
		}
		else{
			move me random(100) to #(random(city.DimensionX), random(city.DimensionY))
		}
	}
	
	
	def Divide(a : real) : real {
		var x = a/2
		return x;
	}
	def Plus(a : real, b : real) : real {
		var x = a + b
		return x;
	}
	
	def Infect(Neighbor : Human, Distance : real) : bool {
		var RandomValue = random(100);	// get a random value 0-99
		 
		// different infection rates based on Distance
		if (Distance <= 0.5) {
			return CalcInfected(Neighbor, RandomValue, 80); // for example, 80% to get infected if Distance <= 0.5
		} 

		if (Distance <= 1) {
			return CalcInfected(Neighbor, RandomValue, 60);
		} 
		
		if (Distance <= 1.5) {
			return CalcInfected(Neighbor, RandomValue, 40);
		} 

		if (Distance <= 2) {
			return CalcInfected(Neighbor, RandomValue, 20);
		} 
	}
	
	def CalcInfected(Neighbor : Human, RandomValue : real, ComparedTo : real) : bool {
			if (RandomValue < ComparedTo) {
				Neighbor.SetInfected(true);
				return true;
			} else {
				return false;
			}		
	}
	

	def recover(){ //antibodies
		if (Infected){
			Infected = false //set not infected
			Immune = true    //set immune
		}		
		
	}
	
	def loss(){		//TODO: add prob for recover() => affects the results
		if(Infected){
			Ticks++
			if(Ticks % 24 === 0){
				if(Energy - random(Energy)<=2){ //15% death rate
					kill me
				}
				if(Energy <= 0 ){
					kill me   //die when energy <= 0
				}else{
					Energy--//loss energy
				}
			}
			if(Ticks/24 >= 15 and Energy >0){ //1 Tick == 1 hour
				recover()
			}
			
		}	
	}
	
		 
	passive Killed() => kill me
	
	passive GetPositionX() => return xcor
	passive GetPositionY() => return ycor
	


}

