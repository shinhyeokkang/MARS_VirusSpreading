model VirusSpreading

use Mars

grid-layer City as city

//Sheep walk around by chance, if you have grass under you, it is eaten
//If there is no grass beneath you, nothing will be done
//Every few rounds a new sheep is spawned
//It receives half of the Energy 
agent Human on City{
	observe var Rule = ""
	observe var Energy : integer //when energy goes to 0, human die.
	observe var Infected : bool = false
	observe var Immune : bool = false
	observe var obedient : bool = false
	//Regulator: "Sheep_gain_from_food" = Energy grows when eating
	// 			 "Sheep_reproduce" = Percentage chance of offspring 
	external observe var Human_gain_by_age : integer
	external observe var obey_ratio : integer
	external observe var government_announce_date : integer 
	
	//var Target : Grass
	
	initialize{
		//Spawn somewhere in the grid when the simulation starts
		pos at #(random(city.DimensionX), random(city.DimensionY))
		
		
		Energy = random(Human_gain_by_age) + 10
		
	}
	
	
	tick{
		Move()
		Infect() // I think infect() is easier to implement than getInfected()
		Recover()// Only when enough time passed after infected 
		 
		if(Infected === true){
			Rule = "Loose health"
			EnergyLoss()
		}else {
			Rule = "R2 - I'm healthy"
		}		
		
	}
	def Move(){
		if(obedient == true&&TargetDistance <= 2&&nearestHuman != nil){
			Rule = "R3 - Social Distancing"
			nearx = nearestHuman.GetPositionX()//runaway from the human
			neary = nearestHuman.GetPositionY()
			x = Human.GetPositionX()//runaway from the human
			y = Human.GetPositionY()
			move me 1 to #(2x-nearx,2y-neary)	
		}
		else{
			move me random(3) to #(random(city.DimensionX), random(city.DimensionY))
		}
	}
	


	 def EatGrass(){
		Energy = Energy + Sheep_gain_from_food
		var grass_available = grass.GetIntegerValue(xcor, ycor)
		grass.SetIntegerValue(xcor, ycor, Math::Max(grass_available-3,0))
	}
	
	def Spawn(percent : integer){
		if(random(100) < percent){
			var newSheep = spawn Sheep at #(xcor, ycor)
			newSheep.SecondInitialize(Energy, Sheep_gain_from_food, Sheep_reproduce)
			Energy = Energy / 2
		}
	}
	//It is executed either 1 step straight or diagonal(1.4243)
	def RandomMove(){
		move me 1 to #(random(grass.DimensionX), random(grass.DimensionY))
	}
	

	def EnergyLoss(){
		Energy = Energy - 1
		if(Energy <= 0) kill me
	} 
	passive Killed() => kill me
	
	//Die "Mutter" gibt dem "Kind" Werte von sich mit

	passive GetPosiotionX() => return xcor
	passive GetPosiotionY() => return ycor
}

